# linked list
## 為什麼要有 linked list?
* 可不連續的儲存在記憶體位置。
* 依使用多寡分配空間，不會有浪費的空間。
* 適合需要頻繁新增、刪除的資料
* 走訪功能
* Block Chain 應用

**linked-List 它是屬於線性的資料結構**，如下圖所示，線性的資料結構就是透過有順序的 **節點** or **元素** 所構成，可以將其比如成跳房子遊戲，我麼需要按照一定的順序去遍歷所有的節點。相反的非線性結構就不需要按照順序去遍歷。
![](/classnote/img-for-readme/linkedlist.jpeg)

## Linked-list VS. Array 
* **Array**(陣列)
    * 優點:
        * 可以隨機訪問(random access)：也就是可以直接透過 index 對Array的資料做存取。
        * 較節省記憶體空間：因為 Linked list 需要多一個 pointer 來記錄下一個 node 的記憶體位置。
    * 缺點：
        * 新增/刪除資料很麻煩：若要在第一個位置新增資料，就需要O(N)時間把矩陣中所有元素往後移動。
        * 若資料數量時常在改變，要時常調整矩陣的大小，會花費較多時間在搬運資料。
        * 無法有效運用空間: 建立 array 時必須給他固定的範圍。
    * 適用時機:
        * 希望能夠快速存取資料。
        * 已知欲處理的資料數量，便能確認矩陣的大小。
        * 要求記憶體空間的使用越少越好。
* **Linked-list**
    * 優點：
        * 新增/刪除資料較簡單: 只要對前一個 note 調整 pointer 即可，不需要像 Array搬動其餘元素。
            * 若是在Linked list的「開頭」新增node，只要O(1)。
            * 若要刪除特定node，或者在特定位置新增node，有可能需要先執行O(N)的「搜尋」。
        * 可以有效運用空間: Linked list的資料數量可以是動態的，不像Array會有resize的問題。
    * 缺點：
        * 搜尋較費時: 因為Linked list沒有index，若要找到特定node，需要從頭開始找起，搜尋的時間複雜度為O(N)。
        * 占較多記憶體: 需要額外的記憶體空間來儲存 pointer。
    * 適用時機：
        * 無法預期資料數量時，使用Linked list就沒有resize的問題。
        * 需要頻繁地新增/刪除資料時。
        * 不需要快速查詢資料。
