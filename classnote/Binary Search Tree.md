# Binary Search Tree

## 定義
 Binary Search Tree（BST）是一個以 tree 為基礎的資料結構。這種數據結構是為了更有效率的儲存與搜尋。下面我們以隨機一個節點做 key，root 也算是一個 key，只是它包含所有子節點。
 
* key 會有三種情況:
  - 1 他沒有任何子節點
  - 2 他有一邊的子節點
  - 3 兩邊皆有子節點
* key 的左子樹中包含的子節點 皆小於 key 值。
* key 的右子樹中包含的子節點皆大於 key 值。
* key 的左子樹與右子樹皆為二元樹（binary tree)。

### 1.Search
利用BST的原理，



### 2.Insert
insert 與 search 的過程很像，從 root 開始遞迴的方式往下搜尋，找到對應的位置插入新的節點（需符合BST的定義）。 如果該值本身以存於 BST 裡則不做任何事，因為基本的 BST 裡不會存在重複值。但是此次作業沒有不能重複值限制，所以我設計的 BST 可存在重複值。


### 3.Delete

1. 目標值是否為 root -> 找尋替補值(兩種方式)
    * 先左在右: 從 root 的左節點往右找最後面的值，切斷其與父節點的連結當作新的節點，將 root 的子樹賦予給新的節點。 (假如說新的節點最後面還有左節點，保留到最後 insert 回tree)
    * 先右在左: 從 root 的右節點往左找最後面的值，切斷其與父節點的連結當作新的節點，將 root 的子樹賦予給新的節點。 (假如說新的節點最後面還有右節點，保留到最後 insert 回tree)
3. 目標值是否存在 
    - if 存在 : 執行3
    - else : 甚麼都不做。
5. 當目標值存在時，遇到的目標節點有下列三種情況:
    * 為葉節點: 直接切斷其與父節點的聯繫，回傳 root。
    * 存在一個子節點: 直接將子節點往上(父節點)連接。
    * 存在兩個子節點: 我取左邊的節點補上原節點。

### 4.Modify
一次的 modify 就是一次的 insert 和 delete。

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
